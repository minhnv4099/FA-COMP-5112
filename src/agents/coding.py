#
#  Copyright (c) 2025
#  Minh NGUYEN <vnguyen9@lakeheadu.ca>
#
import logging
import os
from copy import deepcopy
from typing import Union

from langchain_core.language_models import BaseChatModel
from langchain_core.prompts import (
    ChatPromptTemplate,
    SystemMessagePromptTemplate,
    HumanMessagePromptTemplate
)
from langgraph.config import RunnableConfig
from langgraph.types import Command, Send
from typing_extensions import override, Any

from src.base.agent import AgentAsNode, InputT, register
from src.base.exception import ScriptWithError
from src.base.tool import execute_script, write_script
from src.base.utils import DirectionRouter

logger = logging.getLogger(__name__)


@register(type="agent", name='coding')
class CodingAgent(AgentAsNode, name='Coding', use_model=True):
    """
    The Coding Agent class
    """

    @override
    def __init__(
            self,
            metadata: dict = None,
            input_schema: InputT = None,
            edges: dict[str, tuple[str]] = None,
            tool_schemas: list = None,
            output_schema: Any = None,
            model_name: str = None,
            model_provider: str = None,
            model_api_key: str = None,
            output_schema_as_tool: bool = None,
            chat_model: BaseChatModel = None,
            anchor_folder: str = None,
            system_prompt: str = None,
            human_prompt: str = None,
            fix_error_attempts: int = None,
            **kwargs
    ):
        super().__init__(
            metadata,
            input_schema,
            edges,
            tool_schemas,
            output_schema,
            model_name,
            model_provider,
            model_api_key,
            output_schema_as_tool,
            chat_model,
            **kwargs
        )

        self.anchor_folder = anchor_folder
        """Anchor folder containing scripts generated by model each attempt"""

        self.system_prompt = SystemMessagePromptTemplate.from_template("""
            You're smart assistance and able to generate Python code in Blender
            Your mission are:
                1. Base on given scripts (if available), "query/subtask " and given "docs" to generate code.

            The format looks like:
            ```JSON block
                subtask: <subtask> 
                docs: [<docs>]
                previous: [<previous_code>]
            """)

        self.human_generate_code_template = HumanMessagePromptTemplate.from_template("""
        Help me to write python code using below information:
            subtask: {subtask}
            docs: {docs} 
            previous: {previous_scripts}
            
        With following instructions:
            - Not include 'bmesh' module
            - Delete all materials before writing by import 2 lines after import libraries
                ```
                    bpy.ops.object.select_all(action='SELECT')
                    bpy.ops.object.delete(use_global=False)
                ```
        """)

        self.human_apply_improvements_template = HumanMessagePromptTemplate.from_template("""""")
        self.human_fix_error_template = HumanMessagePromptTemplate.from_template("""""")

        self.fix_error_attempts = fix_error_attempts
        self.fix_error_tries = 0

        self.caller = None
        self.num_queries = 0
        self.query_offset = 0
        self.coding_task = None
        self.latest_queries = None
        self.get_retrieved_docs = None
        self.retrieved_docs = None
        self.current_script = None
        self.previous_scripts = []

        self.copy_state = dict()

    @override
    def __call__(
            self,
            state: InputT | dict,
            runtime: RunnableConfig = None,
            context: RunnableConfig = None,
            config: RunnableConfig = None,
            **kwargs
    ) -> Union[dict, Command, Send, None]:
        logger.info(state['caller'])
        # ----------------------------------------
        # This block is always executed only one time
        # store state from the official call
        if not state['is_sub_call']:
            self.copy_state = deepcopy(state)
            self.copy_state.pop('is_sub_call', None)
            self.copy_state.pop('has_docs', None)
            self.copy_state['num_queries'] = len(state['queries'])
            self.copy_state['query_offset'] = 0
            self.copy_state['previous_scripts'] = []
            self.get_retrieved_docs = False

        if not state['has_docs']:
            return DirectionRouter.go_next(
                method='send',
                node='retriever',
                state={
                    'coding_task': state['coding_task'],
                    'queries': state['queries']
                },
            )
        # store retrieved docs of first queries (official call)
        if not self.get_retrieved_docs:
            self.copy_state['retrieved_docs'] = state['retrieved_docs']
            self.get_retrieved_docs = True
        # later call this agent must pass above
        # ----------------------------------------

        # operate on each query
        try:
            if state['coding_task'] == 'generate':
                script = self._generate_script(state)
            elif state['coding_task'] == "improve":
                assert 'current_script' in state
                script = self._apply_improvements(state)
            else:
                assert 'current_script' in state
                script = self._fix_error(state)

            # when the generated script is error-free,
            # it is also an ending point for recursive calls
            self.copy_state['previous_scripts'].append(script)
            self.copy_state['current_script'] = script
            self.copy_state['query_offset'] += 1

        except ScriptWithError as e:
            self.fix_error_tries += 1
            """Recall Coding Agent if catch command when executing script
            Before fix code, call Retriever Agent to get relevant documents
            `e.command` is a command call retriever with command and command script
            """
            return e.command

        # return original state stored at the beginning
        # as there may be some sub calls from `retriever` that may change state

        if self.copy_state['query_offset'] < self.copy_state['num_queries']:
            # Continue with the next query
            self.fix_error_tries = 0
            next_node = 'coding'
        else:
            # move on to another node if all queries are solved
            if self.copy_state['caller'] == 'planner':
                next_node = 'critic'
            elif self.copy_state['caller'] == 'critic':
                next_node = 'verification'
            elif self.copy_state['caller'] == 'verification':
                next_node = 'verification'
            # elif self.copy_state['caller'] == 'user':
            #     next_node = 'user',
            else:
                return None
        logger.info(f'coding -> {next_node}')
        return DirectionRouter.go_next(node=next_node, state=self.copy_state, method='command')

    def _prepare_by_adding_human_prompt(self, human_prompt):
        return ChatPromptTemplate([
            self.system_prompt,
            human_prompt,
        ])

    def _generate_script(self, state):
        chat_prompt = ChatPromptTemplate([
            self.system_prompt,
            self.human_generate_code_template,
        ])
        # that's called only when coding_task is 'generate', when queries are subtasks
        query = state['queries'][self.copy_state['query_offset']]
        docs = state['retrieved_docs'][self.copy_state['query_offset']]
        # -----------precess docs -----------
        #
        # ----------------------------------
        formatted_prompt = chat_prompt.invoke({
            "subtask": query,
            "docs": docs,
            "previous_scripts": self.previous_scripts,
        })
        # ---------------------------------------------------
        script = self._generate(formatted_prompt)
        # ---------------------------------------------------

        return script

    def _fix_error(self, state) -> str:
        chat_prompt = self._prepare_by_adding_human_prompt(self.human_fix_error_template)

        formatted_prompt = chat_prompt.invoke({
            'script': state['current_script'],
            'error': state['queries'],
            'docs': state['retrieved_docs']
        })

        # ---------------------------------------------------
        fixed_script = self._generate(formatted_prompt)
        # ---------------------------------------------------

        return fixed_script

    def _apply_improvements(self, state):
        chat_prompt = ChatPromptTemplate([
            self.system_prompt,
            self.human_apply_improvements_template,
        ])

        formatted_prompt = chat_prompt.invoke({
            'script': state['current_script'],
            'improvements': state['queries'],
            'docs': state['retrieved_docs'],
        })
        # ---------------------------------------------------
        improved_script = self._generate(formatted_prompt)
        # ---------------------------------------------------
        return improved_script

    def _generate(self, formatted_prompt):
        while True:
            # ----------------------------------
            generated_script = self.anchor_call(formatted_prompt)
            # ----------------------------------

            anchor_file = os.path.join(self.anchor_folder, f"fake_script.py")
            """Anchor file to check error"""
            write_script.invoke({
                "script": generated_script,
                "file_path": anchor_file
            })
            result = execute_script.invoke(input={"script": anchor_file})
            error = result['error']

            if len(error) == 0:
                return generated_script
            if self.fix_error_tries == self.fix_error_attempts:
                # Test script would be fixed successfully
                generated_script = 'import sys'
                return generated_script
            else:
                raise ScriptWithError(command=DirectionRouter.go_next(
                    method='command',
                    node='retriever',
                    state={
                        'current_script': generated_script,
                        'coding_task': 'fix',
                        'queries': [error, ],
                    })
                )

    @override
    def anchor_call(self, *args):
        with open("assets/blender_script/anchor_4.py", 'r') as f:
            return f.read()

    @override
    def chat_model_call(self, formatted_prompt, context):
        response = self.chat_model.invoke(formatted_prompt)
        try:
            generated_script = response.tool_calls[-1]['args']['script']
        except KeyError as e:
            exit()

        return generated_script
